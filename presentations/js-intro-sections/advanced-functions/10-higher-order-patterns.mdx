import { SlideLayout, Image, FlexBox, Box, Text, Notes } from 'spectacle'
import { CodeDisplay, File, Tests } from '../../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## Higher-Order Function Patterns
<CodeDisplay >
  <File name="example.js">
    
```javascript
// 1. Function as argument
function processHabits(habits, operation) {
  return habits.map(operation);
}

// 2. Function as return value
function createMultiplier(factor) {
  return function(points) {
    return points * factor;
  };
}

// 3. Function transformation
function withLogging(fn) {
  return function(...args) {
    console.log(`Calling ${fn.name} with:`, args);
    const result = fn(...args);
    console.log(`Result:`, result);
    return result;
  };
}
```
    
  </File>
</CodeDisplay>

<Notes>
Higher-order functions are functions that operate on other functions, either by taking them as arguments or returning them. This slide shows three fundamental patterns that form the backbone of functional programming in JavaScript.

The first pattern, functions as arguments, is already familiar from array methods like map, filter, and reduce. The processHabits function abstracts the iteration, letting us pass different operations to transform our data.

The second pattern, returning functions, creates specialized versions of more general functions. The createMultiplier example shows how we can create a family of related functions - double, triple, quadruple - from a single factory.

The third pattern, function transformation, is incredibly powerful. The withLogging wrapper adds debugging capabilities to any function without modifying the original. This is the decorator pattern in functional programming - we enhance behavior by wrapping, not inheritance.

These patterns enable code reuse, separation of concerns, and composability. They're essential for understanding modern JavaScript frameworks and libraries, which use higher-order functions extensively.
</Notes>
</SlideLayout.Full>