import { SlideLayout, Image, FlexBox, Box, Text, Notes } from 'spectacle'
import { CodeDisplay, File, Tests } from '../../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## Array Processing Pattern

<Image height="calc(100% - 7rem)" src="https://ctp-presentation-media.s3.us-east-2.amazonaws.com/Array+Processing+Pattern+-+visual+selection.svg" />
<Notes>
This simple pattern is the foundation of all data processing in JavaScript. It's so fundamental that once you understand it, you'll see it everywhere in professional applications.

The pattern mirrors how we naturally think about data problems: 'I have this data, I need to do something to it, and I want specific results.' This mental model makes array processing intuitive and predictable.

In functional programming, this is called a pipeline - data flows through a series of transformations, with each step producing input for the next step. It's like an assembly line where each station adds value to the product.

This pattern scales beautifully. Whether you're processing 3 habits or 3 million user records, the approach remains the same. The methods handle the complexity of iteration for you, so you can focus on the business logic.

Most importantly, this pattern produces clean, readable code. When you see a chain of array methods, you can read it like a recipe: 'filter these items, then map them to that format, then reduce to a single value.' This readability is crucial for maintaining and debugging applications.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Processing Pipeline Example

```javascript
const dailyHabits = [
  { name: 'Exercise', completed: true, points: 10 },
  { name: 'Reading', completed: false, points: 5 },
  { name: 'Meditation', completed: true, points: 8 },
  { name: 'Water', completed: true, points: 3 }
];

// Process: filter completed → extract points → sum total
const totalPoints = dailyHabits
  .filter(habit => habit.completed)     // [Exercise, Meditation, Water]
  .map(habit => habit.points)           // [10, 8, 3]
  .reduce((sum, points) => sum + points, 0); // 21

console.log(`Today's points: ${totalPoints}`);
```
<Notes>
This example perfectly demonstrates the power of method chaining in array processing. Let's trace through each step to understand how data flows through the pipeline.

**Step 1 - filter()**: We start with 4 habits and filter to only completed ones. filter() examines each habit, applies our test (habit.completed), and keeps only those that return true. Result: 3 objects (Exercise, Meditation, Water).

**Step 2 - map()**: We transform the 3 habit objects into just their point values. map() takes each object and extracts the points property. Result: 3 numbers [10, 8, 3].

**Step 3 - reduce()**: We combine the 3 numbers into a single total. reduce() starts with 0 (the initial value) and adds each points value. Result: 21.

Notice how each method receives exactly what the previous method returned. This data flow is automatic - you don't need to create intermediate variables or manage the iteration manually.

The comments show the intermediate results, which is helpful for understanding and debugging. In a real application, you wouldn't include these comments, but they're valuable while learning.

This pattern replaces what would otherwise be a complex loop with multiple temporary variables. The functional approach is more concise, less error-prone, and more expressive about intent.

Compare this to the imperative approach: create variables, write a for loop, add if conditions, manage state. The functional approach handles all that complexity internally, letting you focus on the business logic.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Key Processing Insight

Chain methods to create powerful data processing pipelines

- Each method transforms the data
- Results flow from one method to the next
- Final result is clean and readable
<Notes>
Method chaining is one of JavaScript's most elegant features, and understanding it deeply will make you a much more effective developer.

**Each method transforms the data**: Think of each method as a function that takes an array as input and returns a new array (or single value) as output. This functional approach means no side effects - the original data remains unchanged, preventing bugs caused by accidental mutations.

**Results flow automatically**: The output of each method becomes the input to the next method. This is composition in action - complex operations built from simple, reusable parts. You're essentially building a custom data processing function by combining existing methods.

**Clean and readable code**: Method chaining reads like natural language. 'From daily habits, filter completed ones, map to their points, reduce to total.' Compare this to nested function calls: reduce(map(filter(dailyHabits, completed), toPoints), sum). The chained version is much clearer.

**Common mistake**: Beginners often try to do everything in one method. For example, trying to filter and sum in a single reduce() call. While possible, it's harder to read and debug. Break complex operations into simple steps - each method should have one clear responsibility.

**Debugging tip**: When a chain isn't working, add console.log() statements between methods to see the intermediate results. Or break the chain temporarily into separate lines with intermediate variables.

**Performance note**: Each method creates a new array, which might seem inefficient. In practice, for typical data sizes, the performance cost is negligible compared to the benefits in code clarity and maintainability.
</Notes>
</SlideLayout.Full>