import { SlideLayout, Image, FlexBox, Box, Text, Notes } from 'spectacle'
import { CodeDisplay, File, Tests } from '../../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## Exercise: Building a Habit Tracker
<Notes>
This exercise represents the culmination of everything we've learned about objects. We're building a complete habit tracking system that demonstrates objects containing other objects, method implementation, array manipulation, and practical problem-solving.

The habitTracker object is more sophisticated than our previous examples. It manages a collection of habits (an array of objects) and provides methods to manipulate that collection. This pattern - an object that manages collections of related objects - is fundamental in application development. You'll see it everywhere: a playlist managing songs, a cart managing products, a user account managing preferences.

As you work through this exercise, notice how the object methods handle edge cases. What happens if you try to complete a habit that doesn't exist? How do you prevent adding duplicate habits? These details separate robust code from fragile code. The comprehensive tests help you think through these scenarios systematically.

Pay attention to the data structure decisions. Each habit in the habits array has its own structure with name, category, and completions. The lastCompleted property is particularly interesting - it uses Date objects, showing how objects can contain other objects. This composition creates rich, expressive data models.

The getTotalPoints method demonstrates functional programming concepts within object-oriented code. The reduce method transforms an array of objects into a single value, showing how object-oriented and functional paradigms complement each other.
</Notes>
<CodeDisplay >
  <File name="exercise.js">
```javascript
// Exercise: Build a habit tracker object
// TODO: Create a habitTracker object with:
// 1. habits array to store habit objects
// 2. addHabit(name, category) method
// 3. completeHabit(name) method that finds and marks habit complete
// 4. getTotalPoints() method (each completion = 10 points)

const habitTracker = {
  habits: [],
  
  addHabit(name, category) {
    // Your code here
  },
  
  completeHabit(name) {
    // Your code here
  },
  
  getTotalPoints() {
    // Your code here
  }
};

// Test it
habitTracker.addHabit("Drink Water", "health");
habitTracker.addHabit("Read 30 mins", "learning");
habitTracker.completeHabit("Drink Water");
console.log(habitTracker.getTotalPoints()); // Should be 10
```
```javascript
// Solution: Complete implementation
const habitTracker = {
  habits: [],
  
  addHabit(name, category) {
    const habit = {
      name: name,
      category: category,
      completions: 0,
      lastCompleted: null
    };
    this.habits.push(habit);
    return habit;
  },
  
  completeHabit(name) {
    const habit = this.habits.find(h => h.name === name);
    if (habit) {
      habit.completions++;
      habit.lastCompleted = new Date();
      return true;
    }
    return false;
  },
  
  getTotalPoints() {
    return this.habits.reduce((total, habit) => {
      return total + (habit.completions * 10);
    }, 0);
  }
};

// Test the solution
habitTracker.addHabit("Drink Water", "health");
habitTracker.addHabit("Read 30 mins", "learning");
habitTracker.completeHabit("Drink Water");
console.log(habitTracker.getTotalPoints()); // 10
habitTracker.completeHabit("Read 30 mins");
console.log(habitTracker.getTotalPoints()); // 20
```
  </File>
  <Tests>
```javascript
describe('Habit Tracker Object', () => {
  beforeEach(() => {
    // Reset the tracker before each test
    habitTracker.habits = [];
  });

  describe('addHabit()', () => {
    it('should add a new habit to the habits array', () => {
      habitTracker.addHabit('Exercise', 'health');
      expect(habitTracker.habits).to.have.length(1);
      expect(habitTracker.habits[0]).to.have.property('name', 'Exercise');
      expect(habitTracker.habits[0]).to.have.property('category', 'health');
    });

    it('should add multiple habits', () => {
      habitTracker.addHabit('Exercise', 'health');
      habitTracker.addHabit('Meditate', 'mindfulness');
      habitTracker.addHabit('Read', 'learning');
      expect(habitTracker.habits).to.have.length(3);
    });

    it('should initialize habits with proper structure', () => {
      habitTracker.addHabit('Test Habit', 'test');
      const habit = habitTracker.habits[0];
      expect(habit).to.have.property('completions');
      expect(habit.completions).to.be.a('number');
    });
  });

  describe('completeHabit()', () => {
    beforeEach(() => {
      habitTracker.addHabit('Drink Water', 'health');
      habitTracker.addHabit('Read 30 mins', 'learning');
    });

    it('should mark an existing habit as complete', () => {
      const result = habitTracker.completeHabit('Drink Water');
      expect(result).to.be.true;
      const habit = habitTracker.habits.find(h => h.name === 'Drink Water');
      expect(habit.completions).to.equal(1);
    });

    it('should increment completions on multiple calls', () => {
      habitTracker.completeHabit('Read 30 mins');
      habitTracker.completeHabit('Read 30 mins');
      habitTracker.completeHabit('Read 30 mins');
      const habit = habitTracker.habits.find(h => h.name === 'Read 30 mins');
      expect(habit.completions).to.equal(3);
    });

    it('should return false for non-existent habits', () => {
      const result = habitTracker.completeHabit('Non-existent');
      expect(result).to.be.false;
    });

    it('should update lastCompleted date', () => {
      const before = Date.now();
      habitTracker.completeHabit('Drink Water');
      const after = Date.now();
      const habit = habitTracker.habits.find(h => h.name === 'Drink Water');
      expect(habit.lastCompleted).to.exist;
      expect(habit.lastCompleted.getTime()).to.be.at.least(before);
      expect(habit.lastCompleted.getTime()).to.be.at.most(after);
    });
  });

  describe('getTotalPoints()', () => {
    it('should return 0 when no habits are completed', () => {
      habitTracker.addHabit('Exercise', 'health');
      habitTracker.addHabit('Meditate', 'mindfulness');
      expect(habitTracker.getTotalPoints()).to.equal(0);
    });

    it('should calculate 10 points per completion', () => {
      habitTracker.addHabit('Exercise', 'health');
      habitTracker.completeHabit('Exercise');
      expect(habitTracker.getTotalPoints()).to.equal(10);
    });

    it('should sum points across all habits', () => {
      habitTracker.addHabit('Exercise', 'health');
      habitTracker.addHabit('Meditate', 'mindfulness');
      habitTracker.addHabit('Read', 'learning');
      
      habitTracker.completeHabit('Exercise'); // 10 points
      habitTracker.completeHabit('Exercise'); // 20 points total
      habitTracker.completeHabit('Meditate'); // 30 points total
      habitTracker.completeHabit('Read'); // 40 points total
      
      expect(habitTracker.getTotalPoints()).to.equal(40);
    });

    it('should handle empty habits array', () => {
      expect(habitTracker.getTotalPoints()).to.equal(0);
    });
  });

  describe('Integration tests', () => {
    it('should handle the example scenario correctly', () => {
      habitTracker.addHabit("Drink Water", "health");
      habitTracker.addHabit("Read 30 mins", "learning");
      habitTracker.completeHabit("Drink Water");
      expect(habitTracker.getTotalPoints()).to.equal(10);
    });

    it('should track multiple habits independently', () => {
      habitTracker.addHabit("Morning Run", "health");
      habitTracker.addHabit("Write Journal", "mindfulness");
      
      // Complete habits different number of times
      habitTracker.completeHabit("Morning Run");
      habitTracker.completeHabit("Morning Run");
      habitTracker.completeHabit("Write Journal");
      
      const runHabit = habitTracker.habits.find(h => h.name === "Morning Run");
      const journalHabit = habitTracker.habits.find(h => h.name === "Write Journal");
      
      expect(runHabit.completions).to.equal(2);
      expect(journalHabit.completions).to.equal(1);
      expect(habitTracker.getTotalPoints()).to.equal(30);
    });
  });
});
```
  </Tests>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## What Are Arrays?
    - Ordered collections of values
    - Zero-indexed (first element is at index 0)
    - Can hold any data type, including mixed types
    - Dynamic size - can grow or shrink
    
    **Real-world analogy:**
    - A list of daily habit completions
    - Each day's data stored in order
  </FlexBox>
<Notes>
Arrays are JavaScript's ordered collections, and understanding them is crucial for managing lists of data. This slide introduces arrays in the context of our habit tracker, providing a bridge from objects to collections.

**Ordered collections** means that position matters in arrays. Unlike object properties, which you access by name, array elements are accessed by their numeric position (index). This ordering is perfect for scenarios where sequence matters - like daily habit completions, where you might want to track progress over time.

**Zero-indexing** is a common source of confusion for beginners, but it's universal in programming. The first element is at index 0, the second at index 1, and so on. This means an array with 5 elements has indices 0, 1, 2, 3, 4. The last index is always array.length - 1.

**Mixed data types** in arrays give JavaScript incredible flexibility. You can have an array containing strings, numbers, objects, even other arrays. This is different from strongly-typed languages where arrays must contain elements of the same type. In our habit context, you might have an array like `[habitObject, "completed", new Date(), 10]` storing different types of related information.

**Dynamic sizing** means arrays can grow and shrink during program execution. You don't need to declare a fixed size upfront. The push() method adds elements, pop() removes them, and the array adjusts accordingly. This flexibility makes arrays perfect for data that changes over time, like a growing list of habits or daily completion records.

The real-world analogy connects arrays to something familiar. A daily habit completion list is naturally ordered (by date), contains similar but distinct items (each day's data), and grows over time (new days are added). This mental model helps you recognize when arrays are the right data structure choice.
</Notes>
</SlideLayout.Full>