import { SlideLayout, Image, FlexBox, Box, Text, Notes } from 'spectacle'
import { CodeDisplay, File, Tests } from '../../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## Array Method Patterns for Data Analysis

Common patterns for processing array data
<Notes>
Every application needs to analyze data, and certain patterns appear repeatedly across different domains. Learning these common patterns will make you much faster at solving data problems, whether you're building a habit tracker, e-commerce site, or social media app.

These patterns represent the building blocks of data analysis. By combining them in different ways, you can solve complex analytical problems. Think of them as your data processing toolkit - once you master these patterns, you can handle most array-based challenges.

The key insight is that most data analysis questions fall into these categories: How many? What matches? What's the total? What's different? These patterns provide the answers.

As we go through each pattern, notice how they build on each other. Complex operations often combine multiple patterns in a single chain. The habit tracker application uses all of these patterns to provide meaningful insights to users.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Filtering and Counting

```javascript
const completedDays = records.filter(day => day.completed);
const totalCompleted = completedDays.length;
```

Use `filter()` to select matching items, then count with `.length`
<Notes>
This is probably the most common data analysis pattern you'll use. The combination of filter() and .length answers questions like 'How many users are active?', 'How many orders are pending?', or 'How many habits were completed this week?'

The pattern is simple but powerful: filter() creates a new array containing only items that match your criteria, then .length tells you how many items made it through the filter. It's like asking 'Show me only the green items, then count them.'

Common variations of this pattern:
- `records.filter(day => day.points > 10).length` - Count high-value days
- `habits.filter(h => h.category === 'health').length` - Count health habits
- `users.filter(u => u.lastLogin > yesterday).length` - Count recent users

Be careful with the syntax: `.length` is a property, not a method, so no parentheses. This trips up beginners who write `.length()` which causes an error.

Performance note: This creates an intermediate array with filter(), then counts it. For very large datasets, consider using reduce() to count in a single pass, but for typical applications, the clarity of this pattern outweighs the performance cost.

Debugging tip: If your count seems wrong, console.log() the filtered array before counting to see what made it through the filter.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Mapping for Transformation

```javascript
const pointsOnly = records.map(day => day.points);
const dailyNames = records.map(day => day.date);
```

Use `map()` to extract specific properties from objects
<Notes>
Mapping for transformation is essential when you have objects but only need specific properties. This pattern appears everywhere in UI development - you have user objects but need just their names for a dropdown, or product objects but need just prices for a calculation.

The pattern is conceptually simple: start with an array of complex objects, end with an array of simple values. map() applies your transformation function to each element and collects the results into a new array.

Common transformations:
- Extract properties: `users.map(u => u.email)`
- Format data: `prices.map(p => '$' + p.toFixed(2))`
- Create new objects: `habits.map(h => ({ name: h.name, status: h.completed ? 'Done' : 'Pending' }))`
- Convert types: `strings.map(s => parseInt(s))`

The arrow function syntax `day => day.points` is concise for simple property access. For more complex transformations, use a full function body: `day => { /* complex logic */ return result; }`

Important: map() always returns an array with the same length as the original. If you need to both filter and transform, chain them: `records.filter(condition).map(transformation)`.

This pattern is the foundation of React component rendering, where you map data arrays to JSX elements. Mastering this pattern will make you much more effective at UI development.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Reducing for Totals

```javascript
const totalPoints = records.reduce((sum, day) => {
  return day.completed ? sum + day.points : sum;
}, 0);
```

Use `reduce()` to combine all values into a single result
<Notes>
reduce() is the most powerful but also the most intimidating array method for beginners. Once you understand it, you'll realize it can replicate almost any other array operation. Think of reduce() as a way to 'fold' an array down to a single value.

The reduce() method takes two parameters: a reducer function and an initial value. The reducer function receives two arguments: the accumulator (the running result) and the current item. Your job is to return the new accumulator value.

In this example, we start with 0 (the initial value). For each day, we check if it's completed. If yes, we add its points to the running sum. If no, we keep the sum unchanged. The final result is the total points from completed days.

Common reduce patterns:
- Sum numbers: `numbers.reduce((sum, n) => sum + n, 0)`
- Find maximum: `numbers.reduce((max, n) => n > max ? n : max, -Infinity)`
- Build objects: `items.reduce((obj, item) => { obj[item.id] = item; return obj; }, {})`
- Count occurrences: `words.reduce((counts, word) => { counts[word] = (counts[word] || 0) + 1; return counts; }, {})`

The conditional logic in our example (day.completed ? sum + day.points : sum) shows how reduce() can combine filtering and calculation in one pass. This is more efficient than filter().map().reduce() for large datasets.

Common mistake: forgetting to return the accumulator. Every path through your reducer function must return the new accumulator value.

Debugging tip: Add console.log(sum, day) at the start of your reducer to see how the accumulator changes with each iteration.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Chaining Methods

```javascript
const completedDates = records
  .filter(day => day.completed)
  .map(day => day.date);
```

Combine multiple methods for complex transformations
<Notes>
Method chaining is where array processing becomes truly powerful. By combining simple operations, you can solve complex data problems with clean, readable code. This pattern is the heart of functional programming in JavaScript.

This example demonstrates a common real-world scenario: you have objects, but you only want specific properties from items that match certain criteria. The chain reads naturally: 'from records, filter completed ones, then map to their dates.'

Chaining works because each array method returns a new array (except reduce, which can return anything). This output becomes the input for the next method in the chain. It's composition - building complex behavior from simple parts.

Common chaining patterns:
- Filter then map: `items.filter(condition).map(transform)`
- Map then reduce: `items.map(extract).reduce(combine, initial)`
- Multiple filters: `items.filter(condition1).filter(condition2)`
- Complex pipelines: `data.filter(valid).map(normalize).sort(compare).slice(0, 10)`

Formatting tip: When chains get long, break them across lines with proper indentation. This makes the data flow clear and each step easy to understand.

Performance consideration: Each method in the chain creates a new array and iterates through the data. For very large datasets, consider using a single reduce() or a library like Lodash that provides lazy evaluation.

Debugging chained methods: Break the chain temporarily into separate lines with intermediate variables, or add console.log() statements between methods to inspect the data at each step.

Method chaining is essential for React development, data analysis, and API data processing. Once you're comfortable chaining methods, you'll find yourself solving complex problems with surprisingly little code.
</Notes>
</SlideLayout.Full>