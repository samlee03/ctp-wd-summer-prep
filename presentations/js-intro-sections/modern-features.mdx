import { SlideLayout, Notes } from 'spectacle'
import { CodeDisplay, File, Tests } from '../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## ðŸš€ Modern JavaScript Features
### ES6+ Features That Power Today's JavaScript

- Destructuring and spread syntax
- Template literals and tagged templates
- Optional chaining and nullish coalescing
- Modern array and object methods
- Async patterns and promises

<Notes>
Welcome to Modern JavaScript Features - this is where JavaScript gets really exciting! These ES6+ features aren't just syntactic sugar; they fundamentally change how we write JavaScript, making it more expressive, safer, and more enjoyable to work with.

These features represent the evolution of JavaScript from a simple scripting language to a powerful, full-featured programming language suitable for complex applications. Every feature we'll cover today is designed to solve real problems that developers face daily.

In our habit tracker context, these modern features will make our code cleaner, more readable, and less prone to bugs. Instead of verbose, error-prone traditional syntax, we'll use elegant modern patterns that express our intent clearly.

We'll cover five major categories: destructuring and spread syntax for working with data structures, template literals for string manipulation, optional chaining and nullish coalescing for safe property access, modern array and object methods for data processing, and async patterns for handling asynchronous operations.

Each of these features was added to solve specific pain points in JavaScript development. As we go through them, pay attention not just to the syntax, but to the problems they solve and how they make your code more robust.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Why Modern JavaScript?
- Cleaner, more expressive syntax
- Better error handling and safety
- Improved performance optimizations
- Enhanced developer productivity

### The Evolution:
- ES5 (2009) â†’ ES6/ES2015 â†’ Annual releases
- Each version adds powerful new features

<Notes>
Before we dive into specific features, let's understand why modern JavaScript matters and how we got here.

Cleaner, more expressive syntax means we can write code that directly expresses our intent. Instead of verbose loops and complex property access patterns, we have concise methods that make our code read almost like natural language.

Better error handling and safety comes from features like optional chaining, which prevents the dreaded "Cannot read property of undefined" errors that crash applications. These features help us write defensive code that gracefully handles edge cases.

Improved performance optimizations - modern JavaScript engines can optimize these new syntax patterns better than older approaches. For example, destructuring can be faster than manual property access in some cases.

Enhanced developer productivity is the biggest win. These features reduce boilerplate code, make common patterns easier to express, and help prevent entire categories of bugs.

The evolution timeline is important to understand: ES5 (ECMAScript 5) was released in 2009 and was stable for six years. Then ES6/ES2015 was a massive update that added classes, modules, arrow functions, and many other features. Since then, JavaScript has moved to annual releases, with each version adding focused improvements.

This means JavaScript is constantly evolving, but in a manageable way. You don't need to learn everything at once - each year brings a few new features that solve specific problems.

For our habit tracker, using modern JavaScript means less code, fewer bugs, and more maintainable applications. These aren't just conveniences - they're professional necessities in today's JavaScript development.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Destructuring Assignment

<CodeDisplay>
  <File name="destructuring.js">
```javascript
// Array destructuring
const habits = ['exercise', 'reading', 'meditation'];
const [first, second, third] = habits;
console.log(first); // 'exercise'

// Skip elements
const [primary, , tertiary] = habits;
console.log(primary, tertiary); // 'exercise', 'meditation'

// Object destructuring
const habit = {
  name: 'Exercise',
  category: 'health',
  streak: 7,
  isActive: true
};

const { name, streak, isActive } = habit;
console.log(name, streak); // 'Exercise', 7

// Rename variables
const { name: habitName, category: type } = habit;
console.log(habitName, type); // 'Exercise', 'health'

// Default values
const { points = 0 } = habit;
console.log(points); // 0 (habit.points is undefined)
```
  </File>
</CodeDisplay>

<Notes>
Destructuring is one of the most transformative features in modern JavaScript. It allows you to extract values from arrays and objects using a syntax that mirrors their structure. This isn't just convenient - it makes code more readable and less error-prone.

Array destructuring lets you extract values by position. Instead of writing `const first = habits[0]; const second = habits[1];`, you can declare and assign multiple variables in one clean line. The skip pattern with empty commas is particularly useful when you only need specific elements.

Object destructuring is even more powerful. Instead of writing `const name = habit.name; const streak = habit.streak;`, you extract multiple properties at once. The variable names match the property names by default, making the intent clear.

Renaming during destructuring solves name conflicts. If you already have a variable called `name`, you can extract `habit.name` as `habitName` in the same operation.

Default values prevent undefined errors. If a property doesn't exist, you can provide a fallback value. This is particularly useful with optional properties or when working with APIs that might return incomplete data.

In our habit tracker, destructuring makes working with habit objects much cleaner:

```javascript
// Instead of:
function displayHabit(habit) {
  const name = habit.name;
  const streak = habit.streak;
  const category = habit.category;
  console.log(`${name} (${category}): ${streak} days`);
}

// We can write:
function displayHabit({ name, streak, category }) {
  console.log(`${name} (${category}): ${streak} days`);
}
```

This pattern is everywhere in modern JavaScript - React props, function parameters, API responses, and configuration objects all benefit from destructuring.

Destructuring also works with nested structures, making it powerful for complex data:
```javascript
const user = {
  habits: {
    daily: ['exercise', 'reading'],
    weekly: ['cleaning']
  }
};

const { habits: { daily, weekly } } = user;
```

The key insight is that destructuring mirrors the structure of your data, making the code self-documenting and reducing the chance of accessing wrong properties.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Spread and Rest Operators

<CodeDisplay>
  <File name="spread-rest.js">
```javascript
// Spread operator - "unpacking"
const basicHabits = ['exercise', 'reading'];
const allHabits = [...basicHabits, 'meditation', 'cooking'];
console.log(allHabits); // ['exercise', 'reading', 'meditation', 'cooking']

// Copy arrays (shallow copy)
const habitsCopy = [...basicHabits];

// Spread in function calls
const numbers = [5, 10, 15];
console.log(Math.max(...numbers)); // 15

// Object spread
const habit = { name: 'Exercise', category: 'health' };
const completeHabit = { ...habit, streak: 5, isActive: true };
console.log(completeHabit); 
// { name: 'Exercise', category: 'health', streak: 5, isActive: true }

// Rest operator - "packing"
function createHabit(name, category, ...properties) {
  return {
    name,
    category,
    extra: properties
  };
}

const habit1 = createHabit('Exercise', 'health', 'morning', 'outdoor');
console.log(habit1.extra); // ['morning', 'outdoor']

// Array destructuring with rest
const [first, ...remaining] = ['exercise', 'reading', 'meditation'];
console.log(first);     // 'exercise'
console.log(remaining); // ['reading', 'meditation']
```
  </File>
</CodeDisplay>

<Notes>
The spread and rest operators use the same three-dot syntax (...) but serve opposite purposes. Understanding when to use each is crucial for modern JavaScript development.

The spread operator "unpacks" or "spreads" values. When you see ...variable, you're taking all elements from that variable and spreading them out. This is incredibly useful for combining arrays without mutation. Instead of using concat() or push(), you can create new arrays declaratively.

Array copying with spread creates a shallow copy - a new array with the same elements. This is essential for avoiding reference-sharing bugs, especially in React applications where you need to avoid mutating state.

Function calls with spread eliminate the need for apply(). Instead of Math.max.apply(null, numbers), you can write Math.max(...numbers). Much cleaner and more intuitive.

Object spread is powerful for creating new objects with additional or overridden properties. This pattern is everywhere in modern JavaScript, especially for updating state immutably. You can merge objects, add properties, or override existing ones all in one expression.

The rest operator "packs" values into an array. It's the opposite of spread - instead of unpacking, it collects remaining values. This is perfect for functions that accept a variable number of arguments.

In function parameters, rest parameters let you handle functions with flexible arguments. Instead of using the awkward arguments object, you get a real array that you can use with all array methods.

Array destructuring with rest lets you extract the first few elements and collect the remainder. This is common when processing lists where you need to handle the first item differently from the rest.

For our habit tracker, these patterns are invaluable:

```javascript
// Adding a new habit without mutating original array
const addHabit = (habits, newHabit) => [...habits, newHabit];

// Updating a habit immutably
const updateHabit = (habit, updates) => ({ ...habit, ...updates });

// Function that accepts any number of habit categories
const getHabitsByCategories = (habits, ...categories) => {
  return habits.filter(habit => categories.includes(habit.category));
};
```

The key insight is that spread and rest promote immutable patterns - instead of modifying existing data structures, you create new ones. This leads to more predictable code and fewer bugs.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Template Literals

<CodeDisplay>
  <File name="template-literals.js">
```javascript
// Basic template literals
const habitName = 'Exercise';
const streak = 7;

// Instead of: 'You have completed ' + habitName + ' for ' + streak + ' days!'
const message = `You have completed ${habitName} for ${streak} days!`;
console.log(message); // "You have completed Exercise for 7 days!"

// Multiline strings
const habitSummary = `
  Habit: ${habitName}
  Streak: ${streak} days
  Status: ${streak > 5 ? 'Great!' : 'Keep going!'}
  Next goal: ${streak + 3} days
`;

// Expressions in template literals
const habit = { name: 'Reading', streak: 12, target: 30 };
const progress = `${habit.name}: ${(habit.streak / habit.target * 100).toFixed(1)}% complete`;

// Tagged templates (advanced)
function emphasize(strings, ...values) {
  return strings.reduce((result, string, i) => {
    const value = values[i] ? `**${values[i]}**` : '';
    return result + string + value;
  }, '');
}

const taggedMessage = emphasize`You've completed ${habitName} for ${streak} days!`;
console.log(taggedMessage); // "You've completed **Exercise** for **7** days!"

// HTML templates
function createHabitCard(habit) {
  return `
    <div class="habit-card ${habit.isActive ? 'active' : 'inactive'}">
      <h3>${habit.name}</h3>
      <p>Category: ${habit.category}</p>
      <p>Streak: ${habit.streak} days</p>
      <div class="progress-bar" style="width: ${habit.streak / habit.target * 100}%"></div>
    </div>
  `;
}
```
  </File>
</CodeDisplay>

<Notes>
Template literals revolutionize how we work with strings in JavaScript. They replace the awkward string concatenation patterns that made dynamic strings hard to read and maintain.

Basic template literals use backticks instead of quotes and allow embedded expressions with ${expression} syntax. This makes string building much more readable - you can see the final string structure while writing it, with dynamic parts clearly marked.

The expression inside ${} can be any valid JavaScript expression - variables, function calls, calculations, ternary operators, etc. This makes template literals incredibly flexible for creating dynamic content.

Multiline strings were a major pain point in older JavaScript. You had to use string concatenation or escaped newlines. Template literals preserve line breaks and indentation, making them perfect for HTML templates, SQL queries, or formatted output.

The example showing expressions demonstrates how you can do calculations, call functions, and use conditional logic directly within the template. This is much cleaner than building strings with multiple concatenations.

Tagged templates are an advanced feature that lets you process template literals with a function. The function receives the string parts and the interpolated values separately, allowing you to transform or validate the content. This is used by libraries like styled-components for CSS-in-JS.

HTML templates showcase one of the most common use cases. Instead of complex DOM manipulation or string concatenation, you can write HTML templates that look like actual HTML with dynamic parts clearly marked. This makes UI generation much more maintainable.

For our habit tracker, template literals make generating dynamic content effortless:

```javascript
// Progress messages
const getProgressMessage = (habit) => {
  const percentage = (habit.streak / habit.target * 100).toFixed(1);
  return `${habit.name}: ${percentage}% complete (${habit.streak}/${habit.target} days)`;
};

// Email notifications
const getDailyReminder = (user, habits) => `
  Hi ${user.name}!
  
  Today's habits:
  ${habits.map(h => `- ${h.name} (${h.streak} day streak)`).join('\n  ')}
  
  Keep up the great work!
`;

// API URLs
const getHabitUrl = (userId, habitId) => `/api/users/${userId}/habits/${habitId}`;
```

Template literals make code more readable by keeping the string structure visible while clearly marking dynamic parts. They're essential for modern JavaScript development, especially when building user interfaces or working with APIs.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Optional Chaining & Nullish Coalescing

<CodeDisplay>
  <File name="optional-chaining.js">
```javascript
// The problem: nested property access
const user = {
  name: 'John',
  habits: [
    { name: 'Exercise', stats: { streak: 7 } }
  ]
};

// Without optional chaining - verbose and error-prone
let streak1;
if (user && user.habits && user.habits[0] && user.habits[0].stats) {
  streak1 = user.habits[0].stats.streak;
} else {
  streak1 = 0;
}

// With optional chaining - safe and concise
const streak2 = user?.habits?.[0]?.stats?.streak ?? 0;

// Optional chaining with methods
const userWithMethods = {
  name: 'Jane',
  getHabits() {
    return this.habits || [];
  }
};

// Safe method calls
const habits = userWithMethods?.getHabits?.() || [];

// Nullish coalescing (??): only null or undefined trigger default
const config = {
  theme: 'dark',
  notifications: false,  // This is falsy but valid!
  maxHabits: 0          // This is falsy but valid!
};

// Wrong: || operator treats falsy values as "missing"
const notifications1 = config.notifications || true;     // true (wrong!)
const maxHabits1 = config.maxHabits || 10;              // 10 (wrong!)

// Right: ?? operator only treats null/undefined as missing
const notifications2 = config.notifications ?? true;     // false (correct!)
const maxHabits2 = config.maxHabits ?? 10;              // 0 (correct!)

// Real-world habit tracker example
function displayHabit(habit) {
  return {
    name: habit?.name ?? 'Unnamed Habit',
    category: habit?.category ?? 'General',
    streak: habit?.stats?.currentStreak ?? 0,
    bestStreak: habit?.stats?.bestStreak ?? 0,
    isActive: habit?.isActive ?? true,
    lastCompleted: habit?.dates?.lastCompleted?.toDateString?.() ?? 'Never'
  };
}

// Works even with incomplete data
const incompleteHabit = { name: 'Exercise' };
console.log(displayHabit(incompleteHabit));
// { name: 'Exercise', category: 'General', streak: 0, ... }
```
  </File>
</CodeDisplay>

<Notes>
Optional chaining and nullish coalescing are safety features that prevent some of the most common runtime errors in JavaScript applications. These operators help you write defensive code that gracefully handles missing or undefined data.

Optional chaining (?.operator) lets you safely access nested properties without worrying about intermediate values being null or undefined. Instead of writing long chains of existence checks, you can express the desired property path and let JavaScript handle the safety checks.

The traditional approach requires checking every level of nesting manually. This is verbose, error-prone, and hard to maintain. If you forget one check, your application crashes with "Cannot read property of undefined."

With optional chaining, you write the property path as you normally would, but use ?. instead of . at each level where a value might be missing. If any part of the chain is null or undefined, the entire expression evaluates to undefined instead of throwing an error.

Optional chaining works with array access ([]) and method calls (()), making it versatile for different data access patterns. The ?.() syntax is particularly useful when you're not sure if a method exists or if the object itself exists.

Nullish coalescing (?? operator) solves a different but related problem: providing default values only when values are actually missing (null or undefined), not when they're just falsy.

The || operator has been traditionally used for defaults, but it has a major flaw: it treats all falsy values (false, 0, "", null, undefined) the same way. This causes bugs when legitimate falsy values like false or 0 are valid data.

The ?? operator only triggers for null or undefined, preserving other falsy values. This is crucial for configuration objects, user preferences, and any scenario where false or 0 are meaningful values.

In our habit tracker, these operators are essential for handling real-world data inconsistencies:

```javascript
// API might return incomplete habit data
const processHabitData = (apiResponse) => {
  return {
    id: apiResponse?.id ?? generateId(),
    name: apiResponse?.name ?? 'New Habit',
    streak: apiResponse?.stats?.streak ?? 0,
    isEnabled: apiResponse?.settings?.enabled ?? true, // false is valid!
    notificationCount: apiResponse?.settings?.notifications ?? 0, // 0 is valid!
    lastSync: apiResponse?.metadata?.lastSync?.toISOString?.() ?? null
  };
};

// Safe UI updates
const updateHabitDisplay = (habit) => {
  document.getElementById('habit-name').textContent = habit?.name ?? '';
  document.getElementById('streak').textContent = habit?.streak ?? 0;
  
  // Safe method calls on potentially missing elements
  document.getElementById('progress-bar')?.style?.setProperty('width', `${habit?.progress ?? 0}%`);
};
```

These operators make your code more resilient to API changes, incomplete data, and edge cases that are common in real applications. They're essential tools for building robust JavaScript applications.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Modern Array Methods

<CodeDisplay>
  <File name="array-methods.js">
```javascript
const habits = [
  { name: 'Exercise', category: 'health', streak: 7, isActive: true },
  { name: 'Reading', category: 'learning', streak: 12, isActive: true },
  { name: 'Meditation', category: 'wellness', streak: 3, isActive: false },
  { name: 'Coding', category: 'learning', streak: 15, isActive: true }
];

// find() - first element matching condition
const longStreak = habits.find(habit => habit.streak > 10);
console.log(longStreak?.name); // 'Reading'

// findIndex() - index of first matching element
const inactiveIndex = habits.findIndex(habit => !habit.isActive);
console.log(inactiveIndex); // 2

// some() - true if ANY element matches
const hasLearningHabits = habits.some(habit => habit.category === 'learning');
console.log(hasLearningHabits); // true

// every() - true if ALL elements match
const allActive = habits.every(habit => habit.isActive);
console.log(allActive); // false

// includes() - true if array contains value
const categories = habits.map(h => h.category);
console.log(categories.includes('health')); // true

// Array.from() - create array from iterable or array-like
const habitNames = Array.from(habits, habit => habit.name);
console.log(habitNames); // ['Exercise', 'Reading', 'Meditation', 'Coding']

// flatMap() - map then flatten
const habitTags = habits.flatMap(habit => [habit.category, `${habit.category}-habit`]);
console.log(habitTags); // ['health', 'health-habit', 'learning', 'learning-habit', ...]

// Real-world examples
const getHabitStats = (habits) => ({
  total: habits.length,
  active: habits.filter(h => h.isActive).length,
  averageStreak: habits.reduce((sum, h) => sum + h.streak, 0) / habits.length,
  categories: [...new Set(habits.map(h => h.category))],
  hasLongStreaks: habits.some(h => h.streak > 14),
  allHaveSomeProgress: habits.every(h => h.streak > 0)
});

console.log(getHabitStats(habits));
```
  </File>
</CodeDisplay>

<Notes>
Modern array methods transform how we work with collections in JavaScript. These methods promote functional programming patterns that are more declarative, readable, and less error-prone than traditional loops.

find() and findIndex() solve the common problem of searching for a specific element. Instead of writing a for loop with break statements, you express what you're looking for as a predicate function. find() returns the element itself, findIndex() returns its position.

some() and every() are logical operations on arrays. some() is like an OR operation - true if any element matches. every() is like an AND operation - true if all elements match. These make checking conditions across collections much more expressive.

includes() is a simple but important method for membership testing. It's cleaner than indexOf() !== -1 and more expressive than manual searching.

Array.from() is incredibly versatile. It can convert array-like objects (like NodeLists from DOM queries) to real arrays, or create arrays from iterables. The second parameter is a mapping function, making it a powerful alternative to map() for array creation.

flatMap() combines mapping and flattening in one operation. This is common when each element maps to multiple values that you want in a single flat array. Without flatMap(), you'd need to map() then flat(), which is less efficient.

These methods shine in real-world scenarios. The getHabitStats example shows how you can build complex analytics with clean, readable code. Each operation is expressed declaratively - you describe what you want, not how to get it.

For our habit tracker, these methods enable powerful data processing:

```javascript
// Find habits that need attention (low streaks)
const needAttention = habits.filter(h => h.isActive && h.streak < 3);

// Check if user has habits in all major categories
const requiredCategories = ['health', 'learning', 'wellness'];
const hasAllCategories = requiredCategories.every(category =>
  habits.some(habit => habit.category === category)
);

// Get all unique tags from habits
const allTags = habits.flatMap(habit => habit.tags || []);
const uniqueTags = [...new Set(allTags)];

// Find the most consistent habit
const mostConsistent = habits.reduce((best, current) =>
  current.streak > best.streak ? current : best
);

// Validate that all habits have required properties
const allHabitsValid = habits.every(habit =>
  habit.name && habit.category && typeof habit.streak === 'number'
);
```

The key insight is that these methods let you express complex data operations in a pipeline style that's easy to read, test, and modify. They're essential for building data-driven applications like our habit tracker.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## ðŸŽ¯ Key Takeaways: Modern JavaScript

1. **Destructuring** makes data extraction clean and safe
2. **Spread/Rest** enables immutable patterns and flexible functions
3. **Template literals** solve string building and formatting
4. **Optional chaining** prevents common runtime errors
5. **Modern array methods** enable expressive data processing

### These features work together!
```javascript
const processHabits = (habits) => {
  const activeHabits = habits.filter(h => h.isActive);
  const stats = activeHabits.map(({ name, streak, category }) => ({
    summary: `${name}: ${streak} days`,
    progress: streak / 30,
    type: category
  }));
  return stats.some(s => s.progress >= 1) 
    ? `Great job! ${stats.length} active habits` 
    : `Keep going! Average: ${(stats.reduce((sum, s) => sum + s.progress, 0) / stats.length * 100).toFixed(1)}%`;
};
```

<Notes>
Let's consolidate what we've learned about modern JavaScript features and see how they work together to create powerful, expressive code.

Destructuring makes data extraction clean and safe by letting you extract exactly the properties you need with clear, readable syntax. It eliminates the verbosity of manual property access and makes function parameters self-documenting.

Spread and Rest operators enable immutable patterns that are crucial for modern JavaScript applications. Instead of mutating existing objects and arrays, you create new ones with spread. Rest parameters make functions more flexible and eliminate the need for the arguments object.

Template literals solve the age-old problem of string building and formatting. They make dynamic strings readable and maintainable, especially for HTML generation, user messages, and URL construction.

Optional chaining and nullish coalescing prevent the most common runtime errors in JavaScript - trying to access properties of null or undefined values. They let you write defensive code that gracefully handles missing data.

Modern array methods enable expressive data processing with functional programming patterns. Instead of imperative loops, you use declarative methods that clearly express your intent and are easier to reason about.

The real power comes when these features work together. The example shows a function that combines multiple modern JavaScript features:

- Destructuring in the map function to extract specific properties
- Template literals for creating readable summary strings
- Array methods (filter, map, some, reduce) for data processing
- Optional chaining could be added for safer property access
- Arrow functions for concise syntax

This creates code that is both powerful and readable. Each piece serves a specific purpose, and together they create functionality that would require much more code in older JavaScript.

For your habit tracker and other applications, these modern features aren't just nice-to-have conveniences - they're essential tools for writing maintainable, bug-free code. They help you express complex operations clearly and handle edge cases gracefully.

As you continue learning JavaScript, practice combining these features. They become more powerful when used together, and they'll make you a more effective developer.
</Notes>
</SlideLayout.Full>