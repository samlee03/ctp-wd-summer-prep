import { SlideLayout, Image, FlexBox, Box, Text, Notes } from 'spectacle'
import { CodeDisplay, File, Tests } from '../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## ðŸ“¦ JavaScript Modules
### Organizing Code into Reusable Components

- Understanding module systems
- Import and export syntax
- Creating modular applications
- Managing dependencies

<Notes>
Welcome to JavaScript Modules - one of the most important concepts for building maintainable, scalable applications. Modules are how we organize code into logical, reusable pieces that can be shared across different parts of our application or even different projects entirely.

Before modules, JavaScript applications were often monolithic files that became increasingly difficult to maintain as they grew. Variables polluted the global namespace, dependencies were unclear, and code reuse was difficult. Modules solve all these problems by providing encapsulation, clear interfaces, and dependency management.

In our habit tracker context, modules will let us separate concerns - we might have separate modules for habit data models, user interface components, storage utilities, and analytics functions. Each module has a clear responsibility and well-defined interfaces for communicating with other modules.

We'll cover the evolution from no module system to CommonJS to modern ES6 modules, understanding import/export syntax, organizing code into logical modules, and best practices for modular architecture. These concepts are essential for any serious JavaScript development, whether you're building frontend applications, Node.js servers, or libraries.

Modules aren't just about organization - they enable powerful tooling like bundlers, tree-shaking for smaller builds, and static analysis for better developer tools. Understanding modules is fundamental to modern JavaScript development.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Why Modules?
    - Break code into manageable pieces
    - Avoid global namespace pollution
    - Enable code reuse across projects
    - Clear dependencies and interfaces

    ### Real-world analogy:
    - Like organizing a kitchen: separate stations for prep, cooking, plating
    - Each station has specialized tools and clear responsibilities
    - Chefs can work independently but coordinate through shared interfaces
  </FlexBox>

<Notes>
Let's understand why modules are so crucial for modern JavaScript development by looking at the problems they solve.

Breaking code into manageable pieces is about cognitive load. Human brains can only hold so much complexity at once. When you have a 3000-line JavaScript file, it's impossible to understand all the interactions and dependencies. Modules let you focus on one piece of functionality at a time.

Global namespace pollution was a major problem in early JavaScript. Every variable and function you declared was accessible globally, leading to naming conflicts and accidental overwrites. If two different parts of your application both declared a variable called 'data', they would interfere with each other.

Code reuse across projects becomes possible when functionality is encapsulated in modules. A utility function for formatting dates can be written once in a module and used across multiple applications. Without modules, you'd copy and paste code, leading to maintenance nightmares.

Clear dependencies and interfaces mean you know exactly what each module needs and what it provides. This makes code more predictable, easier to test, and simpler to refactor.

The kitchen analogy is perfect for understanding modular architecture. In a professional kitchen, you don't have one person doing everything. You have specialized stations - prep cooks handle ingredients, line cooks manage specific dishes, pastry chefs handle desserts. Each station has the tools and ingredients it needs, and they coordinate through well-defined processes.

Similarly, in our habit tracker, we might have:
- A 'habit-model' module that handles habit data structures and validation
- A 'storage' module that manages saving and loading data
- A 'ui-components' module that renders habit cards and forms
- An 'analytics' module that calculates streaks and statistics

Each module focuses on its specific responsibility but can work together through clear interfaces to create the complete application.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Understanding Module File Paths
- **Absolute paths**: Start from root directory (e.g., `/src/utils.js`)
- **Relative paths**: Start from current file location (e.g., `./utils.js`, `../utils.js`)
- **File extensions**: `.js` for JavaScript files

**Key insight:** The browser/Node.js needs to know exactly where to find your files!

<Notes>
Before we dive into import/export syntax, it's crucial to understand how module paths work. This is where many beginners get confused, leading to "module not found" errors that can be frustrating to debug.

Absolute paths start from the root of your project or filesystem. In web applications, `/src/utils.js` means "start from the root and look in the src folder for utils.js". These are useful for accessing modules from anywhere in your project without worrying about your current location.

Relative paths are relative to the current file's location. `./utils.js` means "look in the same directory as the current file". `../utils.js` means "go up one directory level, then look for utils.js". `../../shared/utils.js` means "go up two levels, then into the shared folder".

File extensions are usually required in browser environments and Node.js with ES modules. Always include `.js` (or `.mjs` for ES modules in Node.js) to be explicit about what you're importing.

The key insight is that the JavaScript engine (browser or Node.js) needs to resolve these paths to actual files on the filesystem or server. When you write `import utils from './utils.js'`, the engine looks for a file called utils.js in the same directory as the current file.

Common mistakes include:
- Forgetting file extensions: `import './utils'` instead of `import './utils.js'`
- Wrong relative paths: Using `./` when you need `../` or vice versa
- Case sensitivity: `./Utils.js` vs `./utils.js` matters on some systems

For our habit tracker, if we have this structure:
```
src/
  models/
    habit.js
  utils/
    storage.js
  app.js
```

From `app.js`, you'd import: `import { Habit } from './models/habit.js'`
From `habit.js`, you'd import: `import { saveToStorage } from '../utils/storage.js'`

Taking time to understand paths will save you hours of debugging later!
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Module Basics: Export and Import
<CodeDisplay >
  <File name="example.js">
    
```javascript
// habitModel.js - Export individual pieces
export const MAX_HABITS = 10;

export function createHabit(name, category) {
  return {
    id: Date.now(),
    name,
    category,
    streak: 0
  };
}

export class Habit {
  constructor(name) {
    this.name = name;
  }
}

// main.js - Import what you need
import { createHabit, MAX_HABITS } from './habitModel.js';
import { Habit } from './habitModel.js';

const myHabit = createHabit('Exercise', 'health');
```
    
  </File>
</CodeDisplay>

<Notes>
Here we see the fundamental building blocks of the ES6 module system: export and import. This is how modern JavaScript applications share code between files.

Exports define what a module makes available to other modules. In this example, habitModel.js exports three things: a constant MAX_HABITS, a function createHabit, and a class Habit. The export keyword in front of each declaration makes them available for import by other modules.

Notice that we're using named exports here - each export has a specific name that importers must use. This creates explicit, clear interfaces between modules. When someone imports from habitModel.js, they know exactly what's available.

Imports bring functionality from other modules into the current module. The import statement uses destructuring-like syntax to specify exactly what you want from the module. This is selective importing - you only bring in what you need, which can help with performance and clarity.

The path './habitModel.js' is crucial - it tells JavaScript where to find the module. The './' means "in the same directory as the current file".

You can combine multiple imports from the same module in one statement, or separate them as shown. Both approaches work, but combining them is usually more concise.

This pattern creates clear dependency relationships. If main.js imports from habitModel.js, you know that main.js depends on habitModel.js. This makes it easier to understand your application's structure and avoid circular dependencies.

For our habit tracker, this modular approach means we can separate concerns:
- habitModel.js handles the data structure and business logic for habits
- main.js handles the application coordination and user interface
- Each module has a clear, focused responsibility

The beauty of this system is that habitModel.js doesn't need to know anything about main.js - it just exports its functionality and trusts that other modules will use it appropriately.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Types of Exports
    **Named Exports:**
    - Export multiple values from a module
    - Import with exact names (or rename)
    - Can export declarations or statements

    **Default Export:**
    - One default export per module
    - Import with any name
    - Good for main functionality
  </FlexBox>

<Notes>
Understanding the two types of exports is crucial for effective module design. Each serves different purposes and has different use cases.

Named exports are perfect when a module provides multiple related pieces of functionality. You can export constants, functions, classes, or any other values. The key characteristic is that they have specific names that must be used when importing (unless you rename them).

Named exports promote explicit interfaces. When you see `import { createHabit, validateHabit } from './habitUtils.js'`, you immediately know what functionality is being used from that module. This makes code more self-documenting and easier to understand.

You can export at declaration time (`export function createHabit() {}`) or export existing values (`export { createHabit, validateHabit }`). Both approaches work, but exporting at declaration is often cleaner for functions and classes.

Default exports are designed for modules that have one primary piece of functionality. A module can have only one default export, but it can be imported with any name. This is convenient for modules that represent a single concept or class.

Default exports are commonly used for:
- Classes that represent the main concept of the module
- Functions that are the primary purpose of the module  
- Configuration objects or main application components

For our habit tracker:
- A `Habit` class might be a default export because the entire module is about that one concept
- A `habitUtils.js` module might use named exports for `createHabit`, `validateHabit`, `calculateStreak` because it provides multiple utilities
- A `config.js` module might default export a configuration object

The choice between named and default exports affects how your module is used and how clear its interface is. Named exports create more explicit contracts, while default exports are more flexible but can be less clear about what's being imported.

Many modules use both - a default export for the main functionality and named exports for utilities or constants.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Export Syntax Examples
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Named exports - multiple per file
export const VERSION = '1.0.0';
export function helper() {}
export class Tool {}

// Export list
const PI = 3.14;
const E = 2.71;
export { PI, E };

// Export with rename
export { PI as CircleConstant };

// Default export - one per file
export default class HabitTracker {
  // Main module functionality
}

// Mixed exports
export default HabitTracker;
export { VERSION, helper };
```
    
  </File>
</CodeDisplay>

<Notes>
This example shows the complete range of export syntax options in ES6 modules. Understanding these patterns will help you design clean, flexible module interfaces.

Inline exports (`export const VERSION = '1.0.0'`) are convenient when you know something should be exported as you're writing it. This is the most common pattern for constants, functions, and classes that are meant to be public API.

Export lists (`export { PI, E }`) are useful when you want to be explicit about what gets exported, or when you're exporting values that were declared earlier in the file. This pattern also makes it easy to see all exports at a glance.

Export with rename (`export { PI as CircleConstant }`) lets you provide a different public name than the internal name. This is useful for creating more descriptive APIs or avoiding naming conflicts. The internal code uses PI, but consumers import CircleConstant.

Default exports use the `export default` syntax. Notice that you don't need to provide a name - the importing module will choose the name. This works for classes, functions, objects, or any value.

Mixed exports show that you can combine default and named exports in the same module. This is a powerful pattern where you have one main export (like a class) and several supporting utilities or constants.

For our habit tracker, we might structure modules like this:

```javascript
// habit.js - Main Habit class with utilities
export default class Habit {
  constructor(name, category) {
    this.name = name;
    this.category = category;
  }
}

export const HABIT_CATEGORIES = ['health', 'learning', 'productivity'];
export const MAX_HABIT_NAME_LENGTH = 50;
export function validateHabitName(name) {
  return name.length <= MAX_HABIT_NAME_LENGTH;
}
```

This provides a clean interface where consumers can get the main Habit class as the default, and also access related constants and utilities as named exports.

The key principle is to make your exports predictable and discoverable. Someone reading your code should easily understand what your module provides and how to use it.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Import Syntax Examples
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Import named exports
import { helper, Tool } from './utils.js';

// Import with rename
import { PI as Ï€ } from './math.js';

// Import all as namespace
import * as MathUtils from './math.js';
console.log(MathUtils.PI);

// Import default
import HabitTracker from './tracker.js';

// Import default and named together
import HabitTracker, { VERSION } from './tracker.js';

// Import for side effects only
import './initialize.js';
```
    
  </File>
</CodeDisplay>

<Notes>
Import syntax is the other half of the module system equation. These patterns give you flexibility in how you bring functionality into your modules.

Named imports (`import { helper, Tool }`) bring in specific exports by name. This is selective importing - you only get what you explicitly ask for. This helps with performance (bundlers can eliminate unused exports) and clarity (you see exactly what dependencies you're using).

Import with rename (`import { PI as Ï€ }`) solves naming conflicts. If you already have a PI variable in your module, you can import the math module's PI as a different name. This is also useful for creating more convenient or descriptive names.

Namespace imports (`import * as MathUtils`) bring in all exports from a module under a single namespace object. This is useful when a module has many related exports that you want to use with a clear prefix. Instead of importing dozens of individual functions, you access them as MathUtils.functionName.

Default imports (`import HabitTracker`) are the simplest syntax because you choose the name. Since there's only one default export per module, there's no ambiguity about what you're importing.

Combining default and named imports is a common pattern when modules provide both a main export and supporting utilities. This saves you from writing multiple import statements.

Side effect imports (`import './initialize.js'`) run a module's code without importing any values. This is useful for modules that perform setup tasks, register event listeners, or modify global state. The module runs, but you don't need any of its exports.

For our habit tracker, you might see imports like:

```javascript
// app.js
import Habit, { HABIT_CATEGORIES, validateHabitName } from './models/habit.js';
import * as StorageUtils from './utils/storage.js';
import { formatDate } from './utils/date.js';
import './styles/global.css'; // Side effect import for styles

// Now you can use:
const habit = new Habit('Exercise', 'health');
if (validateHabitName(habit.name)) {
  StorageUtils.save('habits', [habit]);
}
```

The key is to import only what you need, use descriptive names, and keep your dependencies clear and explicit.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Habit Storage Module
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Create a habit storage module
// TODO: Build a module that handles habit persistence
// Should export functions for CRUD operations

// habitStorage.js
// TODO: Create these exports:
// 1. saveHabit(habit) - saves to localStorage
// 2. loadHabit(id) - retrieves single habit
// 3. loadAllHabits() - retrieves all habits
// 4. deleteHabit(id) - removes habit
// 5. clearAllHabits() - removes all habits

// Storage key constant (don't export)
const STORAGE_KEY = 'habit_tracker_habits';

// Your implementation here...
```
    
  </File>
</CodeDisplay>

<Notes>
This exercise is designed to give you hands-on practice with module design while building something practical for our habit tracker application. Creating a storage module is a perfect example of modular thinking - separating data persistence concerns from business logic.

The module should encapsulate all localStorage operations for habits. Notice that STORAGE_KEY is declared but not exported - this is an implementation detail that other modules don't need to know about. This demonstrates the encapsulation principle of modules.

When designing this module, think about:

1. **Single Responsibility**: This module only handles storage operations, not habit validation or business logic
2. **Clear Interface**: Each function has a clear purpose and predictable behavior
3. **Error Handling**: What happens if localStorage is unavailable or if data is corrupted?
4. **Data Format**: How do you serialize/deserialize habit objects to/from JSON?

Here's a possible implementation approach:

```javascript
// habitStorage.js
const STORAGE_KEY = 'habit_tracker_habits';

export function saveHabit(habit) {
  const habits = loadAllHabits();
  const existingIndex = habits.findIndex(h => h.id === habit.id);
  
  if (existingIndex >= 0) {
    habits[existingIndex] = habit;
  } else {
    habits.push(habit);
  }
  
  localStorage.setItem(STORAGE_KEY, JSON.stringify(habits));
}

export function loadAllHabits() {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : [];
  } catch (error) {
    console.warn('Failed to load habits from storage:', error);
    return [];
  }
}
```

This exercise teaches important module design principles:
- Keep internal implementation details private
- Provide a clean, predictable public API
- Handle errors gracefully
- Focus on a single responsibility

Once you complete this module, you'll be able to use it anywhere in your application with simple imports like `import { saveHabit, loadAllHabits } from './habitStorage.js'`.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Module Systems
    **ES6 Modules (ESM):**
    - Modern standard (import/export)
    - Static analysis possible
    - Tree-shaking support

    **CommonJS (CJS):**
    - Node.js standard (require/module.exports)
    - Dynamic loading
    - Synchronous by design
  </FlexBox>

<Notes>
Understanding different module systems is important because you'll encounter both in the JavaScript ecosystem, and they each have different characteristics and use cases.

ES6 Modules (ESM) are the official standard for JavaScript modules. They use import/export syntax and are now supported in all modern browsers and Node.js. The key advantage is static analysis - tools can analyze your imports and exports without running the code.

Static analysis enables powerful optimizations:
- **Tree-shaking**: Bundlers can eliminate unused exports, reducing bundle size
- **Dead code elimination**: Tools can detect unused code more effectively  
- **Better IDE support**: Editors can provide accurate autocomplete and refactoring
- **Circular dependency detection**: Tools can catch problematic dependency cycles

Tree-shaking is particularly important for web applications. If you import one function from a library that exports hundreds, bundlers can include only that one function in your final bundle, dramatically reducing file size.

CommonJS is the module system that Node.js used before ES6 modules were standardized. It uses require() to import and module.exports to export. While older, it's still widely used, especially in Node.js applications and older npm packages.

Dynamic loading in CommonJS means you can require modules conditionally or at runtime:
```javascript
if (process.env.NODE_ENV === 'development') {
  const devTools = require('./devTools');
}
```

This flexibility comes with trade-offs - static analysis is much harder, so you lose tree-shaking and other optimizations.

Synchronous design means require() blocks until the module is loaded. This works well in Node.js where modules are loaded from the local filesystem, but would be problematic in browsers where modules might come from slow network requests.

For our habit tracker:
- Use ES6 modules for frontend code and modern Node.js projects
- You might encounter CommonJS when using older npm packages
- Some build tools can convert between formats automatically

The trend is strongly toward ES6 modules, but understanding both helps you work with the entire JavaScript ecosystem.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## CommonJS vs ES6 Modules
<CodeDisplay >
  <File name="example.js">
    
```javascript
// CommonJS (Node.js)
// math.js
module.exports.add = (a, b) => a + b;
module.exports.PI = 3.14159;

// main.js
const math = require('./math');
console.log(math.add(2, 3));

// ES6 Modules
// math.mjs
export const add = (a, b) => a + b;
export const PI = 3.14159;

// main.mjs
import { add, PI } from './math.mjs';
console.log(add(2, 3));
```
    
  </File>
</CodeDisplay>

<Notes>
This side-by-side comparison shows the syntactic and conceptual differences between CommonJS and ES6 modules. Understanding both is important because you'll encounter both in the JavaScript ecosystem.

CommonJS syntax uses `module.exports` to define what the module exports and `require()` to import modules. Notice that require() is a function call that returns an object containing the exports. This makes it dynamic - you can call require() anywhere in your code, even inside if statements or functions.

The CommonJS pattern typically imports the entire module object, then accesses specific properties. This can lead to importing more than you need, but it's straightforward and was the foundation of Node.js's module system for many years.

ES6 module syntax uses `export` declarations and `import` statements. These are language-level constructs, not function calls. This means they must appear at the top level of your module - you can't put them inside functions or conditional blocks.

The destructuring-style import syntax in ES6 modules makes it clear exactly what you're importing from each module. This selective importing helps with tree-shaking and makes dependencies more explicit.

File extensions matter:
- `.js` files in Node.js default to CommonJS
- `.mjs` files are always ES6 modules
- You can configure Node.js to treat `.js` files as ES6 modules with package.json settings

Key differences:

**CommonJS:**
- Dynamic imports (can require conditionally)
- Synchronous loading
- Exports are copies of values
- Widely supported in Node.js ecosystem

**ES6 Modules:**
- Static imports/exports (must be at top level)
- Asynchronous loading (good for browsers)
- Exports are live bindings to values
- Modern standard, better tooling support

For our habit tracker, if you're building for the browser or modern Node.js, use ES6 modules. If you're working with older Node.js code or packages that only support CommonJS, you might need to use CommonJS or use tools that convert between formats.

Many developers are transitioning from CommonJS to ES6 modules, so understanding both helps you work with existing codebases and choose the right approach for new projects.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Modular Habit Tracker
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Exercise: Create a modular habit tracking system
// Split functionality into separate modules

// TODO: Create these modules:
// 1. models/habit.js - Habit class/factory
// 2. services/analytics.js - calculateStreak, getPoints
// 3. services/storage.js - save/load functionality
// 4. utils/validators.js - validation functions
// 5. index.js - main module that combines everything

// models/habit.js
export class Habit {
  // Your implementation
}

// services/analytics.js
export function calculateStreak(completions) {
  // Your implementation
}

// index.js - combine modules
import { Habit } from './models/habit.js';
import { calculateStreak } from './services/analytics.js';
// etc...
```
    
  </File>
</CodeDisplay>
<Notes>
  This is the capstone exercise for the modules section - building a complete modular habit tracking system. This exercise demonstrates how real applications are structured and gives students practice with the architecture patterns they'll encounter in professional development.
  
  **Module breakdown and rationale:**
  
  1. **models/habit.js** - Data models define the structure of your application's data. This module might contain the Habit class or factory function that creates habit objects.
  
  2. **services/analytics.js** - Business logic separated from data models. Functions like calculateStreak and getPoints belong here because they perform calculations on data.
  
  3. **services/storage.js** - Persistence layer abstraction. This isolates all storage operations, making it easy to switch from localStorage to a database later.
  
  4. **utils/validators.js** - Reusable validation functions. These can be used across different modules to ensure data integrity.
  
  5. **index.js** - The orchestrator that brings everything together. This is where you import from other modules and expose your application's public API.
  
  **Key architectural principles:**
  
  - **Separation of Concerns**: Each module has a specific, focused responsibility
  - **Dependency Direction**: Utils and models don't depend on services; services don't depend on the main module
  - **Testability**: Each module can be tested in isolation
  - **Reusability**: Well-designed modules can be reused in other projects
  
  **Common patterns to discuss:**
  
  - **Barrel exports**: index.js can re-export from multiple modules for convenience
  - **Configuration modules**: Separate modules for constants and configuration
  - **Error handling**: Centralized error types in their own module
  
  This exercise prepares students for real-world codebases where proper module organization is crucial for maintainability.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
  <FlexBox alignItems="center" justifyContent="center" flexDirection="column">
    ## Module Best Practices
    - **Single Responsibility** - One module, one purpose
    - **Clear Exports** - Be explicit about public API
    - **Avoid Circular Dependencies** - A imports B imports A
    - **Consistent Naming** - Match file and export names
    - **Documentation** - Document module purpose and exports
    - **Testing** - Test modules in isolation
  </FlexBox>

<Notes>
These best practices will help you design maintainable, scalable module architectures that work well in teams and grow with your application.

Single Responsibility means each module should have one clear purpose. A module should do one thing well rather than trying to handle multiple unrelated concerns. For our habit tracker, separate modules for data storage, UI components, and business logic are better than one module that handles everything.

Clear Exports means being intentional about what you expose as public API. Not everything in a module needs to be exported - keep implementation details private. Use descriptive export names and consider providing a simple, consistent interface even if the internal implementation is complex.

Avoiding Circular Dependencies is crucial for maintainability. If module A imports from module B, and module B imports from module A, you have a circular dependency that can cause initialization problems and make code hard to understand. Restructure your modules to have clear dependency hierarchies.

Consistent Naming helps with discoverability and maintenance. If your file is called `habitValidator.js`, consider exporting a function called `validateHabit` or a class called `HabitValidator`. This makes it easy to guess what imports are available.

Documentation is especially important for modules because they're meant to be used by other parts of your application. Document what each module does, what its exports are for, and any important usage notes. Good module documentation makes onboarding new team members much easier.

Testing modules in isolation ensures they work correctly regardless of how they're used. If a module can be tested independently, it's probably well-designed with clear boundaries and minimal external dependencies.

Practical tips for our habit tracker:

```javascript
// Good: Single responsibility
// habitStorage.js - only handles persistence
// habitValidation.js - only handles validation
// habitAnalytics.js - only handles calculations

// Bad: Multiple responsibilities
// habitUtils.js - handles storage, validation, UI updates, and analytics
```

```javascript
// Good: Clear exports
export { saveHabit, loadHabit, deleteHabit }; // Clear CRUD operations

// Bad: Unclear exports
export { doStuff, helper, process }; // What do these do?
```

Following these practices leads to codebases that are easier to understand, modify, and debug. They're especially important as your application grows beyond what one person can hold in their head.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Dynamic Imports
<CodeDisplay >
  <File name="example.js">
    
```javascript
// Static import (top of file)
import { analyzeHabits } from './analytics.js';

// Dynamic import (anywhere in code)
async function loadAnalytics() {
  const module = await import('./analytics.js');
  return module.analyzeHabits(data);
}

// Conditional loading
if (user.wantsAnalytics) {
  const { generateReport } = await import('./reporting.js');
  generateReport(habits);
}

// Code splitting for performance
button.addEventListener('click', async () => {
  const { showChart } = await import('./charts.js');
  showChart(habitData);
});
```
    
  </File>
</CodeDisplay>
</SlideLayout.Full>

<SlideLayout.Full>
## ðŸŽ¯ Key Takeaways: Modules

1. **Modules** organize code into reusable, maintainable pieces
2. **ES6 modules** are the modern standard (import/export)
3. **Named exports** for multiple values, **default** for main functionality
4. **CommonJS** still common in Node.js (require/module.exports)
5. **Dynamic imports** enable code splitting and lazy loading

### Coming Up Next: Modern JavaScript Features
ES6+ features that make JavaScript more powerful!

<Notes>
Let's consolidate the key insights about JavaScript modules that will serve you throughout your development career.

Modules are fundamentally about organization and maintainability. They solve the problems of global namespace pollution, unclear dependencies, and monolithic code by providing encapsulation and clear interfaces. Every serious JavaScript application uses modules to manage complexity.

ES6 modules with import/export syntax are now the standard across the JavaScript ecosystem. They provide static analysis benefits that enable better tooling, optimization, and developer experience. Use them for all new projects unless you have specific requirements that prevent it.

Understanding when to use named vs default exports helps you design clear module interfaces. Named exports are great for utilities and libraries that provide multiple related functions. Default exports work well for modules that represent a single concept or class.

CommonJS knowledge is still valuable because much of the Node.js ecosystem was built with it, and you'll encounter it in existing codebases and many npm packages. The good news is that many tools can handle both formats, so you don't always need to choose.

Dynamic imports, which we briefly mentioned, are an advanced feature that enables code splitting - loading parts of your application on-demand rather than all at once. This is crucial for performance in large applications.

For your habit tracker and future projects, modules will help you:
- Separate concerns (storage, UI, business logic)
- Enable code reuse across different parts of your application
- Make testing easier by isolating functionality
- Allow multiple developers to work on different parts without conflicts
- Facilitate gradual refactoring and improvement

As you build more complex applications, good module design becomes increasingly important. Start with simple, single-purpose modules and clear interfaces. Your future self (and your teammates) will thank you.

Next, we'll explore modern JavaScript features that make working with modules and building applications even more powerful and enjoyable. These features build on the foundation of modules to create expressive, maintainable code.
</Notes>
</SlideLayout.Full>